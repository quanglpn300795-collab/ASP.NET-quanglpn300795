{"version":3,"sources":["../../src/common/converters.ts"],"sourcesContent":["/**\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { GenkitError, z } from 'genkit';\nimport {\n  CandidateData,\n  MessageData,\n  ModelReference,\n  Part,\n  ToolDefinition,\n} from 'genkit/model';\nimport {\n  FunctionCallingMode,\n  FunctionDeclaration,\n  GenerateContentCandidate as GeminiCandidate,\n  Content as GeminiContent,\n  Part as GeminiPart,\n  Schema,\n  SchemaType,\n} from './types.js';\n\nexport function toGeminiTool(tool: ToolDefinition): FunctionDeclaration {\n  const declaration: FunctionDeclaration = {\n    name: tool.name.replace(/\\//g, '__'), // Gemini throws on '/' in tool name\n    description: tool.description,\n    parameters: toGeminiSchemaProperty(tool.inputSchema),\n  };\n  return declaration;\n}\n\nfunction toGeminiSchemaProperty(property?: ToolDefinition['inputSchema']) {\n  if (!property || !property.type) {\n    return undefined;\n  }\n  const baseSchema: Schema = {};\n  if (property.description) {\n    baseSchema.description = property.description;\n  }\n  if (property.enum) {\n    baseSchema.enum = property.enum;\n  }\n  if (property.nullable) {\n    baseSchema.nullable = property.nullable;\n  }\n  let propertyType;\n  // nullable schema can ALSO be defined as, for example, type=['string','null']\n  if (Array.isArray(property.type)) {\n    const types = property.type as string[];\n    if (types.includes('null')) {\n      baseSchema.nullable = true;\n    }\n    // grab the type that's not `null`\n    propertyType = types.find((t) => t !== 'null');\n  } else {\n    propertyType = property.type;\n  }\n  if (propertyType === 'object') {\n    const nestedProperties = {};\n    Object.keys(property.properties).forEach((key) => {\n      nestedProperties[key] = toGeminiSchemaProperty(property.properties[key]);\n    });\n    return {\n      ...baseSchema,\n      type: SchemaType.OBJECT,\n      properties: nestedProperties,\n      required: property.required,\n    };\n  } else if (propertyType === 'array') {\n    return {\n      ...baseSchema,\n      type: SchemaType.ARRAY,\n      items: toGeminiSchemaProperty(property.items),\n    };\n  } else {\n    const schemaType = SchemaType[propertyType.toUpperCase()] as SchemaType;\n    if (!schemaType) {\n      throw new GenkitError({\n        status: 'INVALID_ARGUMENT',\n        message: `Unsupported property type ${propertyType.toUpperCase()}`,\n      });\n    }\n    return {\n      ...baseSchema,\n      type: schemaType,\n    };\n  }\n}\n\nfunction toGeminiMedia(part: Part): GeminiPart {\n  if (part.media?.url.startsWith('data:')) {\n    // Inline data\n    const dataUrl = part.media.url;\n    const b64Data = dataUrl.substring(dataUrl.indexOf(',')! + 1);\n    const contentType =\n      part.media.contentType ||\n      dataUrl.substring(dataUrl.indexOf(':')! + 1, dataUrl.indexOf(';'));\n    return { inlineData: { mimeType: contentType, data: b64Data } };\n  }\n\n  // File data\n  if (!part.media?.contentType) {\n    throw Error(\n      'Must supply a `contentType` when sending File URIs to Gemini.'\n    );\n  }\n  return {\n    fileData: {\n      mimeType: part.media.contentType,\n      fileUri: part.media.url,\n    },\n  };\n}\n\nfunction toGeminiToolRequest(part: Part): GeminiPart {\n  if (!part.toolRequest?.input) {\n    throw Error('Invalid ToolRequestPart: input was missing.');\n  }\n  return {\n    functionCall: {\n      name: part.toolRequest.name,\n      args: part.toolRequest.input,\n    },\n  };\n}\n\nfunction toGeminiToolResponse(part: Part): GeminiPart {\n  if (!part.toolResponse?.output) {\n    throw Error('Invalid ToolResponsePart: output was missing.');\n  }\n  return {\n    functionResponse: {\n      name: part.toolResponse.name,\n      response: {\n        name: part.toolResponse.name,\n        content: part.toolResponse.output,\n      },\n    },\n  };\n}\n\nfunction toGeminiReasoning(part: Part): GeminiPart {\n  const out: GeminiPart = { thought: true };\n  if (typeof part.metadata?.thoughtSignature === 'string') {\n    out.thoughtSignature = part.metadata.thoughtSignature;\n  }\n  if (part.reasoning?.length) {\n    out.text = part.reasoning;\n  }\n  return out;\n}\n\nfunction toGeminiCustom(part: Part): GeminiPart {\n  if (part.custom?.codeExecutionResult) {\n    return {\n      codeExecutionResult: part.custom.codeExecutionResult,\n    };\n  }\n  if (part.custom?.executableCode) {\n    return {\n      executableCode: part.custom.executableCode,\n    };\n  }\n  throw new Error('Unsupported Custom Part type');\n}\n\nfunction toGeminiPart(part: Part): GeminiPart {\n  if (part.text) {\n    return { text: part.text };\n  }\n  if (part.media) {\n    return toGeminiMedia(part);\n  }\n  if (part.toolRequest) {\n    return toGeminiToolRequest(part);\n  }\n  if (part.toolResponse) {\n    return toGeminiToolResponse(part);\n  }\n  if (typeof part.reasoning === 'string') {\n    return toGeminiReasoning(part);\n  }\n  if (part.custom) {\n    return toGeminiCustom(part);\n  }\n  throw new Error('Unsupported Part type ' + JSON.stringify(part));\n}\n\nfunction toGeminiRole(\n  role: MessageData['role'],\n  model?: ModelReference<z.ZodTypeAny>\n): string {\n  switch (role) {\n    case 'user':\n      return 'user';\n    case 'model':\n      return 'model';\n    case 'system':\n      if (model?.info?.supports?.systemRole) {\n        // We should have already pulled out the supported system messages,\n        // anything remaining is unsupported; throw an error.\n        throw new Error(\n          'system role is only supported for a single message in the first position'\n        );\n      } else {\n        throw new Error('system role is not supported');\n      }\n    case 'tool':\n      return 'function';\n    default:\n      return 'user';\n  }\n}\n\nexport function toGeminiMessage(\n  message: MessageData,\n  model?: ModelReference<z.ZodTypeAny>\n): GeminiContent {\n  let sortedParts = message.content;\n  if (message.role === 'tool') {\n    sortedParts = [...message.content].sort((a, b) => {\n      const aRef = a.toolResponse?.ref;\n      const bRef = b.toolResponse?.ref;\n      if (!aRef && !bRef) return 0;\n      if (!aRef) return 1;\n      if (!bRef) return -1;\n      return parseInt(aRef, 10) - parseInt(bRef, 10);\n    });\n  }\n  return {\n    role: toGeminiRole(message.role, model),\n    parts: sortedParts.map(toGeminiPart),\n  };\n}\n\nexport function toGeminiSystemInstruction(message: MessageData): GeminiContent {\n  return {\n    role: 'user',\n    parts: message.content.map(toGeminiPart),\n  };\n}\n\n/**\n * Converts mode from either genkit tool choice (lowercase)\n * or functionCallingConfig (uppercase).\n * @param from The mode to convert from\n * @returns\n */\nexport function toGeminiFunctionModeEnum(\n  from?: string\n  //genkitMode: 'auto' | 'required' | 'none'\n): FunctionCallingMode | undefined {\n  if (from === undefined) {\n    return undefined;\n  }\n  switch (from) {\n    case 'MODE_UNSPECIFIED': {\n      return FunctionCallingMode.MODE_UNSPECIFIED;\n    }\n    case 'required':\n    case 'ANY': {\n      return FunctionCallingMode.ANY;\n    }\n    case 'auto':\n    case 'AUTO': {\n      return FunctionCallingMode.AUTO;\n    }\n    case 'none':\n    case 'NONE': {\n      return FunctionCallingMode.NONE;\n    }\n    default:\n      throw new Error(`unsupported function calling mode: ${from}`);\n  }\n}\n\nfunction fromGeminiFinishReason(\n  reason: GeminiCandidate['finishReason']\n): CandidateData['finishReason'] {\n  if (!reason) return 'unknown';\n  switch (reason) {\n    case 'STOP':\n      return 'stop';\n    case 'MAX_TOKENS':\n      return 'length';\n    case 'SAFETY': // blocked for safety\n    case 'RECITATION': // blocked for reciting training data\n    case 'LANGUAGE': // blocked for using an unsupported language\n    case 'BLOCKLIST': // blocked for forbidden terms\n    case 'PROHIBITED_CONTENT': // blocked for potentially containing prohibited content\n    case 'SPII': // blocked for potentially containing Sensitive Personally Identifiable Information\n      return 'blocked';\n    case 'MALFORMED_FUNCTION_CALL':\n    case 'OTHER':\n      return 'other';\n    default:\n      return 'unknown';\n  }\n}\n\nfunction fromGeminiThought(part: GeminiPart): Part {\n  return {\n    reasoning: part.text || '',\n    metadata: { thoughtSignature: part.thoughtSignature },\n  };\n}\n\nfunction fromGeminiInlineData(part: GeminiPart): Part {\n  // Check if the required properties exist\n  if (\n    !part.inlineData ||\n    !part.inlineData.hasOwnProperty('mimeType') ||\n    !part.inlineData.hasOwnProperty('data')\n  ) {\n    throw new Error('Invalid GeminiPart: missing required properties');\n  }\n  const { mimeType, data } = part.inlineData;\n  // Combine data and mimeType into a data URL\n  const dataUrl = `data:${mimeType};base64,${data}`;\n  return {\n    media: {\n      url: dataUrl,\n      contentType: mimeType,\n    },\n  };\n}\n\nfunction fromGeminiFileData(part: GeminiPart): Part {\n  if (\n    !part.fileData ||\n    !part.fileData.hasOwnProperty('mimeType') ||\n    !part.fileData.hasOwnProperty('fileUri')\n  ) {\n    throw new Error(\n      'Invalid Gemini File Data Part: missing required properties'\n    );\n  }\n\n  return {\n    media: {\n      url: part.fileData?.fileUri,\n      contentType: part.fileData?.mimeType,\n    },\n  };\n}\n\nfunction fromGeminiFunctionCall(part: GeminiPart, ref: string): Part {\n  if (!part.functionCall) {\n    throw Error(\n      'Invalid Gemini Function Call Part: missing function call data'\n    );\n  }\n  return {\n    toolRequest: {\n      name: part.functionCall.name,\n      input: part.functionCall.args,\n      ref,\n    },\n  };\n}\n\nfunction fromGeminiFunctionResponse(part: GeminiPart, ref?: string): Part {\n  if (!part.functionResponse) {\n    throw new Error(\n      'Invalid Gemini Function Call Part: missing function call data'\n    );\n  }\n  return {\n    toolResponse: {\n      name: part.functionResponse.name.replace(/__/g, '/'), // restore slashes\n      output: part.functionResponse.response,\n      ref,\n    },\n  };\n}\n\nfunction fromExecutableCode(part: GeminiPart): Part {\n  if (!part.executableCode) {\n    throw new Error('Invalid GeminiPart: missing executableCode');\n  }\n  return {\n    custom: {\n      executableCode: {\n        language: part.executableCode.language,\n        code: part.executableCode.code,\n      },\n    },\n  };\n}\n\nfunction fromCodeExecutionResult(part: GeminiPart): Part {\n  if (!part.codeExecutionResult) {\n    throw new Error('Invalid GeminiPart: missing codeExecutionResult');\n  }\n  return {\n    custom: {\n      codeExecutionResult: {\n        outcome: part.codeExecutionResult.outcome,\n        output: part.codeExecutionResult.output,\n      },\n    },\n  };\n}\n\nfunction fromGeminiPart(part: GeminiPart, ref: string): Part {\n  if (part.thought) return fromGeminiThought(part as any);\n  if (typeof part.text === 'string') return { text: part.text };\n  if (part.inlineData) return fromGeminiInlineData(part);\n  if (part.fileData) return fromGeminiFileData(part);\n  if (part.functionCall) return fromGeminiFunctionCall(part, ref);\n  if (part.functionResponse) return fromGeminiFunctionResponse(part, ref);\n  if (part.executableCode) return fromExecutableCode(part);\n  if (part.codeExecutionResult) return fromCodeExecutionResult(part);\n\n  throw new Error('Unsupported GeminiPart type ' + JSON.stringify(part));\n}\n\nexport function fromGeminiCandidate(candidate: GeminiCandidate): CandidateData {\n  const parts = candidate.content?.parts || [];\n  const genkitCandidate: CandidateData = {\n    index: candidate.index || 0,\n    message: {\n      role: 'model',\n      content: parts\n        // the model sometimes returns empty parts, ignore those.\n        .filter((p) => Object.keys(p).length > 0)\n        .map((part, index) => fromGeminiPart(part, index.toString())),\n    },\n    finishReason: fromGeminiFinishReason(candidate.finishReason),\n    finishMessage: candidate.finishMessage,\n    custom: {\n      safetyRatings: candidate.safetyRatings,\n      citationMetadata: candidate.citationMetadata,\n    },\n  };\n\n  return genkitCandidate;\n}\n"],"mappings":"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","names":[]}